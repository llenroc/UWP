# Hello UWP
## A Sample Universal Windows Platform Application
The following sample shows a very basic application that we can run on multiple Windows device families.

### Hello World Step-by-step
1. Run ***Visual Studio 2015*** or later
2. Choose File | New | Project
3. Choose Installed | Templates | Visual C# | Windows | Universal
4. Choose the "Blank App (Universal Windows)" template
5. Name the project "Hello World"
6. Optionally change the location folder
7. Select OK
![New Project Dialog](images/01-New-Project.png)
8. When the version dialog appears, note the minimum and maximum API versions are shown.
9. Select OK in the version dialog. Note that we target a specific UPW version min and max and NOT a Windows Version

![API Version Dialog](images/02-Version-Dialog.png)

#### Solution Files

![Solution Explorer](images/03-Solution-Explorer.png)

There are some interesting things to note about the project structure.  
Open and examine each of these:

***App.xaml and App.xaml.cs***
* Note: XAML files are just XML files that create object hierarchies for code or visuals.
* App.xaml is an Extensible Markup Language (XAML) file where you declare resources that are used across the app.
* App.xaml.cs is the code-behind file for App.xaml. Like all code-behind pages, it contains a constructor that calls the InitializeComponent method. You don't write the InitializeComponent method. It's generated by Visual Studio, and its main purpose is to initialize the elements declared in the XAML file.
* Be careful not to delete the call to InitializeComponent! If you do, all of your GUI elements will disappear!
* App.xaml.cs is the entry point for your app.
* App.xaml.cs also contains methods to handle activation and suspension of the app.

***MainPage.xaml***
* MainPage.xaml is where you define the UI for your app. You can add elements directly using XAML markup, or you can use the design tools provided by Visual Studio.
* MainPage.xaml.cs is the code-behind page for MainPage.xaml. It's where you add your app logic and event handlers.
* Together these two files define a new class called MainPage, which inherits from Page, in the HelloWorld namespace.

***Package.appxmanifest***
A manifest file that describes your app: its name, description, tile, start page, etc.
Includes a list of the files that your app contains.

***Logos***
* Assets/Square150x150Logo.scale-200.png represents your app in the start menu.
* Assets/StoreLogo.png represents your app in the Windows Store.
* Assets/SplashScreen.scale-200.png is the splash screen that appears when your app starts.

***project.json***
* This file contains any package dependencies that you might have.
* Note, you can still use the Package Manager GUI for NuGet, and it will update this file. Give this a try.

### Modify and run the app
Let's add a simple text block to the application.
1. Open the MainPage.xaml file
2. Add the following XAML inside the Grid that's on the page.

```xaml
<TextBlock 
    Text="Hello World!" 
    VerticalAlignment="Center" 
    HorizontalAlignment="Center" 
    FontSize="48" />
```
3. You should see a screen that looks like this:
![Main Page XAML](images/04-MainPage.png)
4. Click ***Local Machine*** to test the application on the desktop. You should see something like the following:
![Running on the desktop](images/05-Desktop-Run.png)

### Running on other platforms
#### Windows Phone
Next let's try running this application on a Windows Phone. We'll just use the phone emulator for this test.  
**Note**: This step requires that you installed the emulators. This can be done when you installed Visual Studio or you can download and install them here: [Windows SDK and emulator archive](https://developer.microsoft.com/en-us/windows/downloads/sdk-archive)  
This step will take a while the first time you run the emulator.  
1. In the dropdown next to ***Local Machine*** in the debug toolbar select a mobile emulator such as the 5" 720p 1G device
![Mobile Emulator Selection](images/06-Mobile-Emulator-Selection.png)
2. Click the run button in the debug toolbar. You should see something like this:
![Running on the mobile](images/07-Mobile-Run.png)
3. When you stop the application, use the red stop button in the debug toolbar. That way, the emulator will stay running if you need to keep using it.  
![Stop Button](images/08-Stop-Button.png)
#### Raspberry Pi
**Note**: For instructions on getting started with Windows 10 IoT Core on Raspberry Pi, visit [http://www.windowsondevices.com/](http://www.windowsondevices.com/).
1. Double click on **Properties** in the solution explorer.
![Project Properties](images/09-Project-Properties.png)
2. Click the **Debug** tab. Select **ARM** from the platform dropdown, then select **Remote Machine** from the **Target device** dropdown.
![Debug Settings](images/10-Debug-Remote-Machine.png)
3. Click **Find** or type in the IP Address of your IoT device if you know it.
![Find Device](images/11-Find-Device.png)
4. We're now ready to run on the Raspberry Pi. If you have a monitor connected to the Raspberry Pi, you should see this screen just before you run:
![Raspberry Pi Info Screen](images/12-Raspberry-Pi-Info.png)
5. Click **Remote Machine** in the debug toolbar. It will take a couple of minutes to deploy the application package to the Raspberry Pi and start the remote debugger. The first time you run the debugger will be slower due to the need to install framework packages, etc.
![Hello World on Raspberry Pi!](images/13-Raspberry-Pi-Hello-World.png)
6. Click the **red** box in the debug toolbar to stop debugging.

### Adaptive Code
The following code will require a Raspberry Pi running Windows 10 IoT Core and an LED connected to GPIO pin 24.
**Note:** Make sure you use a proper resistor for you LED. For the Raspberry Pi, this would be 220 Ohms.
- Connect the shorter leg of the LED to GPIO 24 (pin 18 on the expansion header) on the RPi2 or RPi3. 
- Connect the longer leg of the LED to the resistor. 
- Connect the other end of the resistor to one of the 3.3V pins on the RPi2 or RPi3. 

1. Now let's add a code file to the solution. Choose ***Add | Class***
![](images/14-Add-New-Class.png)
2. Name the class ***BlinkyService***
3. Replace the generated code with the following:
```C#
using System;
using Windows.Devices.Gpio;
using Windows.Foundation.Metadata;
using Windows.UI.Xaml;

namespace Hello_World
{
    /// <summary>
    /// This is a very simple service for blinking an LED.
    /// </summary>
    public class BlinkyService
    {
        private readonly string gpioType = "Windows.Devices.Gpio.GpioController";
        private readonly int pinNumber;
        private DispatcherTimer timer;
        private GpioPinValue pinValue;
        private GpioPin pin;

        int blinkRate;
        public int BlinkRate
        {
            get
            {
                return blinkRate;
            }
            set
            {
                blinkRate = value;
                if (timer != null)
                    timer.Interval = TimeSpan.FromMilliseconds(blinkRate);
            }
        }

        public BlinkyService(int pinNumber)
        {
            this.pinNumber = pinNumber;
        }

        /// <summary>
        /// Is blinking a light possible on this device?
        /// </summary>
        public bool CanBlink
        {
            get
            {
                //NOTE: This is where we use the adaptable code feature of UWP.
                return ApiInformation.IsTypePresent(gpioType);
            }
        }

        // This is a "fire and forget" timer.
        public void Start()
        {
            if (!InitializeGpio())
                return;

            timer = new DispatcherTimer();
            timer.Interval = TimeSpan.FromMilliseconds(BlinkRate);
            timer.Tick += TimerTick;

            if (pin != null)
            {
                timer.Start();
            }
        }

        private void TimerTick(object sender, object e)
        {
            if (pinValue == GpioPinValue.High)
                pinValue = GpioPinValue.Low;
            else
                pinValue = GpioPinValue.High;

            pin.Write(pinValue);
        }


        private bool InitializeGpio()
        {
            var gpio = GpioController.GetDefault();

            // No GPIO controller found
            if (gpio == null)
            {
                pin = null;                
                return false;
            }

            pin = gpio.OpenPin(pinNumber);
            pinValue = GpioPinValue.High;
            pin.Write(pinValue);
            pin.SetDriveMode(GpioPinDriveMode.Output);

            return true;
        }
    }
}
```
4. Now modify ***MainPage.xaml*** with the following code:
```xaml
<Grid Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
        <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
            <TextBlock Text="Hello World!" FontSize="48"/>
            <Button Content="Start LED" FontSize="48" HorizontalAlignment="Center" Click="Button_Click" />
        </StackPanel>
    </Grid>
```

5. Finally add this code to ***MainPage.xaml.cs***
```
public sealed partial class MainPage : Page
{
    BlinkyService blinky = new BlinkyService(pinNumber:24);

    public MainPage()
    {
        this.InitializeComponent();
    }

    private void Button_Click(object sender, RoutedEventArgs e)
    {
        if (blinky.CanBlink)
        {
            blinky.BlinkRate = 500;
            blinky.Start();
        }
    }
}
```
6. Examine the code for BlinkyService. In particular note the CanBlink method. This method uses ApiInformation to determine if the given API is supported on the device on which the code is running. This is an example of Adaptive Code in action.

7. In addition to individual APIs, we can also test for API Contracts which are versioned groups of APIs.

8. Run the code and click the button to see what happens. If all is wired correctly, you should get a blinking LED!
